* 포인터 
- 변수의 주소를 저장하는 변수.
- 메모리 상에 위치한 특정한 데이터의 (시작)주소값을 보관하는 변수
포인터에서 &와 * 의미.
*는 포인터라고 선언하는 것
&는 주소를 가르킨다고 하는 것 
int main(){
  int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  
  for(int i = 0; i < 10; i++){
    std::cout << arr[i] << std::endl;
  }
  
  for(int i = 0; i < 10; i++){
    std::cout << *(arr + i)<< std::endl;
  }
  
  for(int *ptr = arr; ptr < arr + 10; prt++){
    std::cout << *ptr << std::endl;
  }
}

*ptr = arr 이란?
ptr이라는 포인터를 만들고 arr이라는 값을 넣는다. arr은 &arr[0]이다. 즉 arr[0]번째 주소를 뜻한다.
즉, ptr에 &arr[0](arr배열의 0번째 주소)에 *(값)을 넣는다. -> arr[0]의 값은 1.
*prt = 1;

*(arr + i) 이란?
위에 설명했듯이 arr = &arr[0] 이고, arr + 1 = &arr[0] + 1 이라고 설명 가능하다.
그리고 여기서 Point는 + 1 은 앞에 배열의 형에 따라 값이 달라진다.
int형은 메모리 상에서 한 칸에 4byte를 나타낸다. 즉, + 1은 4byte가 더 생긴 것이다. -> 이 부분은 주소를 찍어 확인할 수 있다.
따라서 *(arr + 1) = &arr[0] + 1의 값(*)을 넣는다. 즉, arr[2]의 값인 2를 넣는 것이다.

// arr[i] == *(arr + i) == *(par + i) == *(i + par) == i[par]
// par[i] == i[par] 값이 똑같은 이유 -> a[b] -> *(a + b)로 계산하기 때문.

* 배열 포인터 (어렵게 느껴 질 수 있지만 실무에서 쓰인다.) - 배열을 가리키는 포인터
ex) int (*par)[3] -> 3짜리  int형 배열을 가리키는 포인터(*par)
* 포인터 배열 - 포인터들이 배열
ex) int *par[3] -> 3짜리 배열이 생기고 그 안에는 각각 다른 값을 가르키는 포인터들이 들어있다.
- 차이점은 ()가 있고 없고이다.
par[0] = &a;
par[1] = &c;
par[2] = &b;

1. 00개의 정수를 입력받아 첫 줄에 짝수 번째 숫자들을 순서대로 출력하고,
다음 줄에 홀수 번째 숫자들을 순서대로 출력하라.
입력 예)
7
3 1 4 1 5 9 2
출력 예)
1 1 9
3 4 5 2

2.
int main() {
	int a = 10;
	int b = 20;

	int* ptr;

	ptr = &a;
	*ptr = 30;

	ptr = &b;
	*ptr = 10;

	std::cout << "a :" << a << std::endl;
	std::cout << "b :" << b << std::endl;
	std::cout << "*prt :" << *ptr << std::endl;

	return 0;
}
