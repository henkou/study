함수의 오버로딩
- C 에서는 같은 함수의 사용은 안되지만 C++ 같은 이름의 함수를 여러번 사용하여도 가능하다.
- 구분 가능한 이유는 호출할 시에 사용한 인자를 보고 판단을 한다.
- 함수를 오버로딩 하는 과정
1 단계
자신과 타입이 정확히 일치하는 함수를 찾는다.

2 단계
정확히 일치하는 타입이 없는 경우 아래와 같은 형변환을 통해서 일치하는 함수를 찾아본다.

Char, unsigned char, short 는 int 로 변환된다.

Unsigned short 는 int 의 크기에 따라 int 혹은 unsigned int 로 변환된다.

Float 은 double 로 변환된다.

Enum 은 int 로 변환된다.

3 단계
위와 같이 변환해도 일치하는 것이 없다면 아래의 좀더 포괄적인 형변환을 통해 일치하는 함수를 찾는다.

임의의 숫자(numeric) 타입은 다른 숫자 타입으로 변환된다. (예를 들어 float -> int)

Enum 도 임의의 숫자 타입으로 변환된다 (예를 들어 Enum -> double)

0 은 포인터 타입이나 숫자 타입으로 변환된 0 은 포인터 타입이나 숫자 타입으로 변환된다

포인터는 void 포인터로 변환된다.

4 단계
유저 정의된 타입 변환으로 일치하는 것을 찾는다 (이 부분에 대해선 나중에 설명!)

만약에 컴파일러가 위 과정을 통하더라도 일치하는 함수를 찾을 수 없거나 
같은 단계에서 두 개 이상이 일치하는 경우에 모호하다 (ambiguous) 라고 판단해서 오류를 발생하게 됩니다.

* 생성자
- 객체의 생성과 초기화를 담당하는 특별한 기능
Date day(2011, 3, 1);         // 암시적 방법 (implicit)
Date day = Date(2012, 3, 1);  // 명시적 방법 (explicit)
//보통 암시적 방법을 많이 사용.

* 디폴트 생성자
- 인자를 하나도 가지지 않는 생성자.
- 클래스에서 사용자가 어떠한 생성자도 명시적으로 정의하지 않았을 경우에 컴파일러가 자동으로 추가해주는 생성자.

* 모든 내용은 모두의 코드 에서 인용한 글입니다. 
