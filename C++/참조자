1. 참조자, reference
1-1 포인터와 참조자의 차이

포인터란?
메모리의 주소를 가지고 있는 변수이다. 메모리 값을 보관하는 변수.
주소 값을 통한 메모리 접근을 한다.(간접 참조)

레퍼런스란?
레퍼런스 = 참조자 (C++에만 있는 문법)
자신이 참조하는 변수를 대신할 수 있는 또 하나의 이름이다.
즉, 변수에 별명(별칭)을 하나 붙여 주는 것이다.
변수 명을 통해서 메모리를 참조한다(직접 참조)
상수의 경우 레터럴이기 때문에 coast를 붙여 줘야 한다. 리터럴은 지금 생각은 int형같은 경우 메모리가 생성되지 않는다? -->틀림
즉, 프로그램을 실행하면 메모리 상의 특별한 곳에 goodbye, why so serious, %c 와 같은 리터럴들이 쭈르륵 보관되어 있는 공간이 생긴다는 것입니다.
리터럴은 소스 코드 상에서 고정된 값을 가지는 것들 이라고 이야기 했습니다. 
다시 말해서 실제 프로그램 실행 중에서도 리터럴의 값은 절대로 변경 되서는 안된다는 것입니다.
따라서 리터럴이 보관 되는 곳은 읽기만 가능.
레퍼런스의 레퍼런스,레퍼런스의 배열, 레퍼런스의 포인터는 존재할 수 없다.

포인터    =  메모리 주소 변경가능 =>  참조할 주소 이동가능 => 운영체제에 돌아가는 모든 메모리를 제어가능 
레펀런스 =  메모리 주소 변경불가 => 참조할 주소 이동불가 =>  해당프로그램 안에서 정해진 이름으로만 사용가능

차이점.

1. null 초기화
포인터는 NULL 초기화를 할 수 있지만, 레퍼런스는 NULL 초기화를 할 수 없다.
레퍼런스는 반드시 선언과 동시에 초기화를 해야 한다.
2. 메모리 공간의 소모
포인터는 주소 값을 저장하기 위해 별도의 메모리 공간을 소모한다.
레퍼런스는 같은 메모리 공간을 참조하므로 메모리 공간을 소모하지 않는다.
--> 질문. 
레퍼런스가 메모리 상에 반드시 존재해야 하는 경우는 어떤 경우가 있을까요? 
그리고 메모리 상에 존재할 필요가 없는 경우는 또 어떤 경우가 있을까요?
--> 답변.
1) 호출 스택이 달라질 때, 해당 메모리에 접근하기 위해 주소가 필요하다. 주소 메모리 공간이 필요하다.
2) 호출 스택이 같을 때, 바로 접근하며 따로 주소 메모리 공간이 불필요하다.


3. call by pointer / call by reference
매개 변수로 함수 인자 전달 시, 메모리 소모가 일어나고, 값 복사가 발생된다.
메모리 소모가 없고, 값 복사 또한 발생하지 않는다.
